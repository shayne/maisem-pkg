// Copyright (c) Tailscale Inc & AUTHORS
// SPDX-License-Identifier: BSD-3-Clause

// Code generated by tailscale.com/cmd/cloner; DO NOT EDIT.

package agent

import (
	"encoding/json"
	"time"

	"tailscale.com/types/ptr"
)

// Clone makes a deep copy of Message.
// The result aliases no memory with the original.
func (src *Message) Clone() *Message {
	if src == nil {
		return nil
	}
	dst := new(Message)
	*dst = *src
	if src.Content != nil {
		dst.Content = make([]MessageContent, len(src.Content))
		for i := range dst.Content {
			dst.Content[i] = *src.Content[i].Clone()
		}
	}
	return dst
}

// A compilation failure here means this code must be regenerated, with the command at the top of this file.
var _MessageCloneNeedsRegeneration = Message(struct {
	Role    Role
	Content Content
}{})

// Clone makes a deep copy of MessageContent.
// The result aliases no memory with the original.
func (src *MessageContent) Clone() *MessageContent {
	if src == nil {
		return nil
	}
	dst := new(MessageContent)
	*dst = *src
	dst.Data = append(src.Data[:0:0], src.Data...)
	dst.ToolUse = src.ToolUse.Clone()
	if dst.ToolResults != nil {
		dst.ToolResults = ptr.To(*src.ToolResults)
	}
	if dst.CacheControl != nil {
		dst.CacheControl = ptr.To(*src.CacheControl)
	}
	return dst
}

// A compilation failure here means this code must be regenerated, with the command at the top of this file.
var _MessageContentCloneNeedsRegeneration = MessageContent(struct {
	Type             ContentType
	Thinking         string
	Signature        string
	MediaType        string
	Data             json.RawMessage
	RedactedThinking string
	Text             string
	ToolUse          *ToolUse
	ToolResults      *ToolResult
	CacheControl     *CacheControl
}{})

// Clone makes a deep copy of ToolUse.
// The result aliases no memory with the original.
func (src *ToolUse) Clone() *ToolUse {
	if src == nil {
		return nil
	}
	dst := new(ToolUse)
	*dst = *src
	dst.Input = append(src.Input[:0:0], src.Input...)
	return dst
}

// A compilation failure here means this code must be regenerated, with the command at the top of this file.
var _ToolUseCloneNeedsRegeneration = ToolUse(struct {
	ID    string
	Name  string
	Input json.RawMessage
}{})

// Clone makes a deep copy of ToolResult.
// The result aliases no memory with the original.
func (src *ToolResult) Clone() *ToolResult {
	if src == nil {
		return nil
	}
	dst := new(ToolResult)
	*dst = *src
	return dst
}

// A compilation failure here means this code must be regenerated, with the command at the top of this file.
var _ToolResultCloneNeedsRegeneration = ToolResult(struct {
	Name       string
	ToolCallID string
	Output     string
	Error      bool
}{})

// Clone makes a deep copy of CacheControl.
// The result aliases no memory with the original.
func (src *CacheControl) Clone() *CacheControl {
	if src == nil {
		return nil
	}
	dst := new(CacheControl)
	*dst = *src
	return dst
}

// A compilation failure here means this code must be regenerated, with the command at the top of this file.
var _CacheControlCloneNeedsRegeneration = CacheControl(struct {
	Type string
}{})

// Clone makes a deep copy of Usage.
// The result aliases no memory with the original.
func (src *Usage) Clone() *Usage {
	if src == nil {
		return nil
	}
	dst := new(Usage)
	*dst = *src
	return dst
}

// A compilation failure here means this code must be regenerated, with the command at the top of this file.
var _UsageCloneNeedsRegeneration = Usage(struct {
	InputTokens              int
	OutputTokens             int
	CacheCreationInputTokens int
	CacheReadInputTokens     int
}{})

// Clone makes a deep copy of MessagesRequest.
// The result aliases no memory with the original.
func (src *MessagesRequest) Clone() *MessagesRequest {
	if src == nil {
		return nil
	}
	dst := new(MessagesRequest)
	*dst = *src
	if src.Messages != nil {
		dst.Messages = make([]Message, len(src.Messages))
		for i := range dst.Messages {
			dst.Messages[i] = *src.Messages[i].Clone()
		}
	}
	if src.Tools != nil {
		dst.Tools = make([]ToolDefinition, len(src.Tools))
		for i := range dst.Tools {
			dst.Tools[i] = *src.Tools[i].Clone()
		}
	}
	if dst.ToolChoice != nil {
		dst.ToolChoice = ptr.To(*src.ToolChoice)
	}
	if dst.ConversationState != nil {
		dst.ConversationState = ptr.To(*src.ConversationState)
	}
	return dst
}

// A compilation failure here means this code must be regenerated, with the command at the top of this file.
var _MessagesRequestCloneNeedsRegeneration = MessagesRequest(struct {
	System            string
	MaxTokens         int
	Messages          []Message
	Tools             []ToolDefinition
	ToolChoice        *ToolChoice
	ThinkingMode      bool
	ThinkingTokens    int
	ConversationState *ConversationState
}{})

// Clone makes a deep copy of MessagesResponse.
// The result aliases no memory with the original.
func (src *MessagesResponse) Clone() *MessagesResponse {
	if src == nil {
		return nil
	}
	dst := new(MessagesResponse)
	*dst = *src
	if src.Content != nil {
		dst.Content = make([]MessageContent, len(src.Content))
		for i := range dst.Content {
			dst.Content[i] = *src.Content[i].Clone()
		}
	}
	return dst
}

// A compilation failure here means this code must be regenerated, with the command at the top of this file.
var _MessagesResponseCloneNeedsRegeneration = MessagesResponse(struct {
	ID               string
	StopReason       string
	Content          Content
	Usage            Usage
	TimeToFirstToken time.Duration
	ResponseTime     time.Duration
}{})

// Clone makes a deep copy of ToolChoice.
// The result aliases no memory with the original.
func (src *ToolChoice) Clone() *ToolChoice {
	if src == nil {
		return nil
	}
	dst := new(ToolChoice)
	*dst = *src
	return dst
}

// A compilation failure here means this code must be regenerated, with the command at the top of this file.
var _ToolChoiceCloneNeedsRegeneration = ToolChoice(struct {
	Type string
	Name string
}{})

// Clone makes a deep copy of ToolDefinition.
// The result aliases no memory with the original.
func (src *ToolDefinition) Clone() *ToolDefinition {
	if src == nil {
		return nil
	}
	dst := new(ToolDefinition)
	*dst = *src
	dst.InputSchema = append(src.InputSchema[:0:0], src.InputSchema...)
	return dst
}

// A compilation failure here means this code must be regenerated, with the command at the top of this file.
var _ToolDefinitionCloneNeedsRegeneration = ToolDefinition(struct {
	Name        string
	Description string
	InputSchema json.RawMessage
}{})

// Clone makes a deep copy of Tool.
// The result aliases no memory with the original.
func (src *Tool) Clone() *Tool {
	if src == nil {
		return nil
	}
	dst := new(Tool)
	*dst = *src
	return dst
}

// A compilation failure here means this code must be regenerated, with the command at the top of this file.
var _ToolCloneNeedsRegeneration = Tool(struct {
	Name    string
	Desc    string
	summary func(inputJSON json.RawMessage) string
	Schema  string
	Handler toolUseHandler
}{})
